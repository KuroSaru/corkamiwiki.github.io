#summary the Portable Executable Format on Windows
#labels WIP
=*_DRAFT IN PROGRESS_*=

=PE=
 * This page deals with the PE format, or more specifically, x86/x64 Windows (from XP to W7) binaries (ie, not other OSes or systems, not OBJ format, etc...)
 * It deals with the reality of the loader, not the theory of the format itself.
 * All proof of concepts are included with source.
  * They're all working and clean.
  * They're all generated in asssembly, by hand, from scratch, so no superfluous information is included (they might be wrongly detected as suspicious for that)
  * [https://corkami.googlecode.com/svn repository directory] [http://code.google.com/p/corkami/downloads/list?q=CPC source and binary download].
<wiki:toc max_depth="3" />

=required elements=
a standard (high aligments, sections, imports) PE such as `normal.exe` can be defined with only the following structure elements:
{{{
    at IMAGE_DOS_HEADER.e_magic, db 'MZ'
    at IMAGE_DOS_HEADER.e_lfanew, dd NT_Signature - IMAGEBASE
...
    at IMAGE_NT_HEADERS.Signature, db 'PE', 0, 0
...
    at IMAGE_FILE_HEADER.Machine,               dw IMAGE_FILE_MACHINE_I386
    at IMAGE_FILE_HEADER.NumberOfSections,      dw NUMBEROFSECTIONS
    at IMAGE_FILE_HEADER.SizeOfOptionalHeader,  dw SIZEOFOPTIONALHEADER
    at IMAGE_FILE_HEADER.Characteristics,       dw IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_32BIT_MACHINE
...
    istruc IMAGE_OPTIONAL_HEADER32
    at IMAGE_OPTIONAL_HEADER32.Magic,                     dw IMAGE_NT_OPTIONAL_HDR32_MAGIC
    at IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint,       dd EntryPoint - IMAGEBASE
    at IMAGE_OPTIONAL_HEADER32.ImageBase,                 dd IMAGEBASE
    at IMAGE_OPTIONAL_HEADER32.SectionAlignment,          dd SECTIONALIGN
    at IMAGE_OPTIONAL_HEADER32.FileAlignment,             dd FILEALIGN
    at IMAGE_OPTIONAL_HEADER32.MajorSubsystemVersion,     dw 4
    at IMAGE_OPTIONAL_HEADER32.SizeOfImage,               dd 2 * SECTIONALIGN
    at IMAGE_OPTIONAL_HEADER32.SizeOfHeaders,             dd SIZEOFHEADERS
    at IMAGE_OPTIONAL_HEADER32.Subsystem,                 dw IMAGE_SUBSYSTEM_WINDOWS_CUI
    at IMAGE_OPTIONAL_HEADER32.NumberOfRvaAndSizes,       dd 16
...
    at IMAGE_DATA_DIRECTORY_16.ImportsVA,   dd Import_Descriptor - IMAGEBASE
...
    at IMAGE_SECTION_HEADER.VirtualSize,      dd 1 * SECTIONALIGN
    at IMAGE_SECTION_HEADER.VirtualAddress,   dd 1 * SECTIONALIGN
    at IMAGE_SECTION_HEADER.SizeOfRawData,    dd 1 * FILEALIGN
    at IMAGE_SECTION_HEADER.PointerToRawData, dd 1 * FILEALIGN
    at IMAGE_SECTION_HEADER.Characteristics,  dd IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE
}}}
so everything else is not required.

=structure by structure=

==DOS Header ('MZ Header')==
 * starts at offset 0
 * most values only matters to the DOS stub.
  * `compiled.exe` contains a DOS stub
   {{{
   DOS_HEADER:
...
    .e_cparhdr     dw (dos_stub - DOS_HEADER) >> 4 ; defines MZ stub entry point
...

align 010h, db 0

dos_stub:
bits 16
    push    cs
    pop     ds
    mov     dx, dos_msg - dos_stub
    mov     ah, 9
    int     21h
    mov     ax, 4c01h
    int     21h
dos_msg
    db 'This program cannot be run in DOS mode.', 0dh, 0dh, 0ah, '$'
}}}

==e_magic===
 * = `MZ`
 * it could be `ZM` on an (non-PE) EXE. These executables still work under XP via ntvtm.
  * `dosZMXP.exe` is a non-PE EXE with a ZM signature
  {{{
      at IMAGE_DOS_HEADER.e_magic, db 'ZM'
}}}

===e_cparhrd===
 * points to the dos stub, shifted by 4 (count of paragraphs)

===e_lfanew===
 * is a relative offset to the NT Headers.
  * `tiny.exe` has a `e_lfanew` of 4, which means the NT Headers is overlapping the DOS Header.
 {{{
DOS_HEADER:
.e_magic dw 'MZ'

align 4, db 0

istruc IMAGE_NT_HEADERS
    at IMAGE_NT_HEADERS.Signature, db 'PE',0,0
...
    at IMAGE_OPTIONAL_HEADER32.SectionAlignment,          dd 4      ; also sets e_lfanew
    at IMAGE_OPTIONAL_HEADER32.FileAlignment,             dd 4
}}}
  * `appendedhdr.exe` and `apphdrW7.exe` have both a `e_lfanew` of 400h, which puts the NT Headers in appended data. However, it's required under XP that the Header is extended till there via !SizeOfHeaders.

==Rich header==
 * is an unofficial structure generated by compilers.
 * has no consequence on PE execution
 * is not documented officially, but documented by _lifewire_ and _Daniel Pistelli_.
  * `compiled.exe` contains a Rich Header
 {{{
align 16, db 0
RichHeader:
RichKey EQU 092033d19h
dd "DanS" ^ RichKey     , 0 ^ RichKey, 0 ^ RichKey       , 0 ^ RichKey
dd 0131f8eh ^ RichKey   , 7 ^ RichKey, 01220fch ^ RichKey, 1 ^ RichKey
dd "Rich", 0 ^ RichKey  , 0, 0
align 16, db 0
}}}
==NT Headers ('PE Header')==
 * has to be dword-aligned.

===Machine===
 * `014c` for 32b
 * `8664` for 64b

===!NumberOfSections===
 * can be null with low alignment PEs
  * `nosection*.exe`, `tiny*.exe`
 * can be up to 96 under XP:
  * `96emptysections.exe` (all identical), `96workingsections.exe` (all physically different), `maxsecXP.exe` (garbage table)
 * can be up to 65536 (no perfect PoC yet due to Yasm limitations)
  * `maxsecW7.exe`: 8192 physically different code sections
  * `maxsec_lowaligW7.exe`: 6666 garbage sections.

===!TimeDateStamp===
 * has a different meaning whether it's a Borland or a Microsoft compiler
 * is used for bound imports check

=====!PointerToSymbolTable/!NumberOfSymbols=====
no importance whatsoever for the loader

===!SizeOfOptionalHeader===
 * is not the size of the optional header, just the delta between the top of the Optional header and the start of the section table.
 Thus, it can be null (the section table will overlap with the Optional Header, or can be null when no sections are present) or as big as the file (the section table will be in virtual space, full of zero).
  * `nullSOH-XP` is a PE with a null !SizeOfHeaders. the section table is thus overlapping the optional header. (XP only).
    {{{
...
SECTIONALIGN equ 4
FILEALIGN equ 4
...
OptionalHeader:                                                                                     ; Section Table
istruc IMAGE_OPTIONAL_HEADER32
    at IMAGE_OPTIONAL_HEADER32.Magic,                     dw IMAGE_NT_OPTIONAL_HDR32_MAGIC
    at IMAGE_OPTIONAL_HEADER32.SizeOfInitializedData,     dd EntryPoint - IMAGEBASE                 ; VirtualSize (duplicate value to accept loading)
    at IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint,       dd EntryPoint - IMAGEBASE                 ; SizeOfRawData
...
}}}
  * `virtsectblXP` is a PE with its 82 sections of empty information, with its section table in virtual space.
{{{
...
    at IMAGE_FILE_HEADER.NumberOfSections,      dw 82 ; 0 <= NumberOfSections <= 82 (varies with SizeOfOptionalHeader)
...
SIZEOFOPTIONALHEADER equ 10h + $ - IMAGEBASE ; bigger than the file itself !
; section table starts here...
<EOF>
}}}
 * standard value: `E0`

 ==Optional Header==

===Magic===
 * `10b` for 32b
 * `20b` for 64b

=====!MajorLinkerVersion/!MinorLinkerVersion=====
unused

=====!SizeOfCode/!SizeOfInitializedData/!SizeOfUninitializedData=====
unused

===!AddressOfEntryPoint===
 * can be null
  * `nullEP.exe` has a null !EntryPoint: Execution starts at !ImageBase, executing 'MZ' as 'dec ebp/pop edx'
  {{{
EntryPoint:
istruc IMAGE_DOS_HEADER
    at IMAGE_DOS_HEADER.e_magic, db 'MZ'

    push Msg
    call [__imp__printf]
    add esp, 1 * 4
    push 0
    call [__imp__ExitProcess]

    at IMAGE_DOS_HEADER.e_lfanew, dd NT_Signature - IMAGEBASE
}}}
 * can be negative
  * `dllextep-ld` has an external !EntryPoint that is located in `dllextep.dll` (a dll with no relocations)
   * `dllext-ep`:
   {{{
IMAGEBASE equ 1000000h
}}}
   * `dllextep-ld`:
   {{{
IMAGEBASE equ 33000000h
...
    at IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint,       dd 1001008h - IMAGEBASE
}}}

=====!BaseOfCode/!BaseOfData=====
unused

===!ImageBase===
 * is a multiple of 10000h
 * can be null, under XP. In this case, the binary will be relocated to 1000h
  * `ibnullXP.exe` has a null imagebase, and relocations
 * can be any value as long as `ImageBase + 'SizeOfImage' < 80000000h`
  * `bigib.exe` has an !ImageBase of 7ffd0000h, and no relocations
 * if the !ImageBase is bigger than that, the binary will be relocated to 10000h
  * `ibkernel.exe` has an !ImageBase of 0FFFF0000h and relocations.

===!SectionAlignment/!FileAlignment===
 * both are power of 2 (4, 8, 16...)
 * standard mode: `200 <= FileAlignment <= SectionAlignment` and `1000 <= SectionAlignment`
  * `normal.exe` has aligments of 1000/200
  * `bigalign.exe` has alignments of 20000000/10000
 * in low alignment: `4 <= FileAlignment = SectionAlignment <= 800`
  * all `tiny*.*`, `nosection*.exe` have alignments of 4/4

=====!MajorOperatingSystemVersion/!MinorOperatingSystemVersion/!MajorImageVersion/!MinorImageVersion=====
 * unused

===!MajorSubsystemVersion===
 * has to be 4

=====!MinorSubsystemVersion=====
 * unused

=====Reserved1 (!Win32Version)=====
 * not covered yet
 * can override Major/Minor !OperatingSystem/Image Versions

===!SizeOfImage===

===!SizeOfHeaders===

===!CheckSum===
 * simple algorithm
 * required for drivers only

===Subsystem===
 * a CONSOLE PE is exactly like a GUI PE except that it comes with a pre-attached console.
 * a DRIVER PE only requires a correct checksum to work correctly.

=====!DllCharacteristics=====
 * not necessary
  * `dll.dll` is a working DLL with this value set to 0

=====!SizeOfStackReserve/!SizeOfStackCommit/!SizeOfHeapReserve/!SizeOfHeapCommit=====
 * can be zero, but not any value
  * `normal.exe` has these value set to zero.
=====!LoaderFlags=====

===!NumberOfRvaAndSizes===
 * rounded down to 16 if bigger (can be `FFFF`)
 * can be 0 `tiny.exe`, etc...

==Optional Header==
 * is anything but optional on a windows executable.


==data directories==

===exports===
 * like many data directories, Exports' size are not necessary
 * Characteristics, !TimeDateStamp, !MajorVersion and !MinorVersion are not necessary.
 * Base is only used for ordinal imports
  * `dll.dll` has a small export table, for one named entry:
 {{{
    at IMAGE_DATA_DIRECTORY_16.ExportsVA,  dd Exports_Directory - IMAGEBASE
...
Exports_Directory:
  Characteristics       dd 0
  TimeDateStamp         dd 0
  MajorVersion          dw 0
  MinorVersion          dw 0
  Name                  dd aDllName - IMAGEBASE
  Base                  dd 0
  NumberOfFunctions     dd NUMBER_OF_FUNCTIONS
  NumberOfNames         dd NUMBER_OF_NAMES
  AddressOfFunctions    dd address_of_functions - IMAGEBASE
  AddressOfNames        dd address_of_names - IMAGEBASE
  AddressOfNameOrdinals dd address_of_name_ordinals - IMAGEBASE
...
aDllName db 'dll.dll', 0
...
address_of_functions:
    dd __exp__Export - IMAGEBASE
NUMBER_OF_FUNCTIONS equ ($ - address_of_functions) / 4
...
address_of_names:
    dd a__exp__Export - IMAGEBASE
NUMBER_OF_NAMES equ ($ - address_of_names) / 4
...
address_of_name_ordinals:
    dw 0
...
a__exp__Export db 'export', 0
}}}
 * the Export Name is not necessary, and can be anything.
  * `dllweirdexp.dll` is correctly exported, with a corrupted Export Name
  {{{
Exports_Directory:
...
  Name                  dd VDELTA + aDllName - IMAGEBASE
...
aDllName db 'completely unrelated dll name', 1, 2, 3, 4, 0
}}}
 * export names can have any value (even null or more than 65536 characters long, with unprintable characters). just null terminated.
  * `dllemptyexp-ld.exe` loads `dllemptyexp.dll` with a null export
  * `dllweirdexp-ld.exe` loads `dllweirdexp.dll` with a 131102-long non-Ascii export.
 * an .EXE can have exports (no need of relocation nor DLL flag), and can use them normally
  * `ownexports.exe` uses its own exports
 * exports at fixed value can be used to encode data, when their values are filled in the Import Address Table
  * `exportsdata.exe`'s code is stored as dodgy exports RVAs, and is restored when imports are resolved
  {{{
EntryPoint:
ownexports.exe_iat:
    dd 80000000h ; => dd 000101468h => 68 14100010   push 10001014
    dd 80000001h ; => dd 04015FF10h => FF15 40100010 call [10001040]
    dd 80000002h ; => dd 083100010h => 83C4 04       add esp,4
    dd 80000003h ; => dd 0CCC304C4h => C3            retn
    dd 0
...
Exports_Directory:
...
address_of_functions:
dd 000101468h - IMAGEBASE
dd 04015FF10h - IMAGEBASE
dd 083100010h - IMAGEBASE
dd 0CCC304C4h - IMAGEBASE
NBFUNCTIONS equ ($ - address_of_functions) / 4
...
}}}
 * fake exports values can disrupt proper disassembly
  * `exportobf.exe` contains fake exports to make disassembly harder
 * ordinals-only exports can make the structure even smaller (no !NumberOfFunctions/!NumberOfNames/!AddressOfNames/!AddressOfNameOrdinals). Fake entries can be also present in exports as long as Base + Ordinal matches the wanted export.
  * `impbyord.exe` calls its own imports by ordinals
  * `dllord-ld.exe` is importing export #314 from `dllord.dll`
   * `dllord-ld.exe`
 {{{
dll.dll_iat:
__imp__export:
    dd 1 << 31 | 314h ; highest bit set to indicate imports by ordinal
}}}
   * `dllord.dll`
 {{{
 Exports_Directory:
...
  Base                  dd 313h
...
  AddressOfFunctions    dd address_of_functions - IMAGEBASE
...

address_of_functions:
    dd -1                                   ; bogus entry that will be 313h
    dd __exp__Export - IMAGEBASE
}}}

===imports===
 * Imports size is not used. !ImportAddressTable is typically not required (excepted in low alignments, under XP)
  * `dll-ld.exe` imports `dll.dll` with a small import table:
{{{
    at IMAGE_DATA_DIRECTORY_16.ImportsVA,   dd Import_Descriptor - IMAGEBASE
...
EntryPoint:
    call [__imp__export]
...

Import_Descriptor:
...
dll.dll_DESCRIPTOR:
    dd dll.dll_hintnames - IMAGEBASE
    dd 0, 0
    dd dll.dll - IMAGEBASE
    dd dll.dll_iat - IMAGEBASE
;terminator
    dd 0, 0, 0, 0, 0
...
dll.dll_hintnames:
    dd hndllexport - IMAGEBASE
    dd 0
...
hndllexport:
    dw 0
    db 'export', 0
...
dll.dll_iat:
__imp__export:
    dd hndllexport - IMAGEBASE
    dd 0
...
dll.dll db 'dll.dll', 0
}}}
 * under XP and later, a DLL can be called by his filename only (no extension). Extension is required under Win2K.
  * `imports_noext.exe` imports DLLs without extensions.
 {{{
kernel32.dll db 'kernel32', 0
msvcrt.dll db 'msvcrt', 0
}}}
 * a DLL can be dynamically loaded via ANSI (LoadLibraryA) or UNICODE (LoadLibraryW).
 * like in any filename, case of the DLL can be mixed
  * `imports_mixed.exe` imports DLLs with mixed case names.
 {{{
kernel32.dll db 'KernEl32', 0
msvcrt.dll db 'mSVCrT', 0
}}}
 * the Import Name Table is not required and can be replaced with the Import Adress Table
  * `imports_noint.exe` contains no INT, the import descriptor are linking twice to the IAT.
  {{{
...
Import_Descriptor:
kernel32.dll_DESCRIPTOR:
    dd kernel32.dll_iat - IMAGEBASE
    dd 0, 0
    dd kernel32.dll - IMAGEBASE
    dd kernel32.dll_iat - IMAGEBASE
...
}}}
 * imports are not necessary. either don't call any API (ex, resource placeholders), or locate Kernel32 and its exports by hand (not covered here)
===resources===
 * directory-like structure.
 {{{
...
at IMAGE_DATA_DIRECTORY_16.ResourceVA, dd Directory_Entry_Resource - IMAGEBASE
...
push SOME_TYPE              ; lpType
push SOME_NAME              ; lpName
push 0                      ; hModule
call [__imp__FindResourceA]
...
Directory_Entry_Resource:
; root directory
istruc IMAGE_RESOURCE_DIRECTORY
    at IMAGE_RESOURCE_DIRECTORY.NumberOfIdEntries, dw 1
iend
istruc IMAGE_RESOURCE_DIRECTORY_ENTRY
    at IMAGE_RESOURCE_DIRECTORY_ENTRY.NameID, dd SOME_TYPE    ; .. resource type of that directory
    at IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData, dd (1<<31) | (resource_directory_type - Directory_Entry_Resource)
iend

resource_directory_type:
istruc IMAGE_RESOURCE_DIRECTORY
    at IMAGE_RESOURCE_DIRECTORY.NumberOfIdEntries, dw 1
iend
istruc IMAGE_RESOURCE_DIRECTORY_ENTRY
    at IMAGE_RESOURCE_DIRECTORY_ENTRY.NameID, dd SOME_NAME ; name of the underneath resource
    at IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData, dd (1<<31) | (resource_directory_language - Directory_Entry_Resource)
iend

resource_directory_language:
istruc IMAGE_RESOURCE_DIRECTORY
    at IMAGE_RESOURCE_DIRECTORY.NumberOfIdEntries, dw 1
iend
istruc IMAGE_RESOURCE_DIRECTORY_ENTRY
at IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData, dd resource_entry - Directory_Entry_Resource
iend

resource_entry:
istruc IMAGE_RESOURCE_DATA_ENTRY
    at IMAGE_RESOURCE_DATA_ENTRY.OffsetToData, dd resource_data - IMAGEBASE
    at IMAGE_RESOURCE_DATA_ENTRY.Size1, dd RESOURCE_SIZE
iend

resource_data:
Msg db " * message stored in resources", 0ah, 0
RESOURCE_SIZE equ $ - resource_data
}}}
 * in standard, 3 levels: `Root/Type/Name/Language` but anything else is possible.

   * loops are possible
    * `resourceloop.exe` contains several loops between resource directories
    {{{
resource_directory_type:
...
    at IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData,  dd (1<<31) | (resource_directory_loop - Directory_Entry_Resource)
...

resource_directory_loop:
...
; double level recursivity
...
    at IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData,  dd (1<<31) | (resource_directory_type - Directory_Entry_Resource)
...
; direct recursivity
...
    at IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData,  dd (1<<31) | (resource_directory_loop - Directory_Entry_Resource)
}}}

 * Names and Types of a resource can be used:
  * immediate integers (aka IDs) - like `resource.exe`
  {{{
SOME_TYPE equ 315h
SOME_NAME equ 7354h
...
push SOME_TYPE              ; lpType
push SOME_NAME              ; lpName
push 0                      ; hModule
call [__imp__FindResourceA]
...
at IMAGE_RESOURCE_DIRECTORY_ENTRY.NameID, dd SOME_TYPE    ; .. resource type of that directory
...
at IMAGE_RESOURCE_DIRECTORY_ENTRY.NameID, dd SOME_NAME ; name of the underneath resource
}}}
  * immediate integers (aka IDs) converted as string for loading - like `resource2.exe`
  {{{
push atype                  ; lpType
push ares                   ; lpName
push 0                      ; hModule
call [__imp__FindResourceA]
...
atype db '#315', 0
ares db "#7354", 0
...
SOME_TYPE equ 315
SOME_NAME equ 7354
...
at IMAGE_RESOURCE_DIRECTORY_ENTRY.NameID, dd SOME_TYPE    ; .. resource type of that directory
...
at IMAGE_RESOURCE_DIRECTORY_ENTRY.NameID, dd SOME_NAME ; name of the underneath resource
...
}}}
  * strings (aka Names). the Name in resource directory is with the format `length + widestring` - like `namedresource.exe`
  {{{
push arestype               ; lpType
push aresname               ; lpName
push 0                      ; hModule
call [__imp__FindResourceA]
...
aresname db 'RES', 0
arestype db 'TYPE', 0
...
    .NumberOfNamedEntries dw 0
    .NumberOfIdEntries    dw 1
    .ID dd (1 << 31) | (alrestype - resource_directory)    ; .. resource type of that directory
...
    .NumberOfNamedEntries dw 0
    .NumberOfIdEntries    dw 1
    .ID dd (1 << 31) | (alresname - resource_directory)  ; name of the underneath resource
...
; length + widestring
alresname dw 3, "R", "E", "S", 0
alrestype dw 4, "T", "Y", "P", "E", 0
}}}
 * the resource structures are relative to the start of the Data Directory, but the resource data can be anywhere in the file (RVA)
  * `reshdr.exe` has its resource data in the PE header
  {{{
at IMAGE_DOS_HEADER.e_magic, db 'MZ'
at IMAGE_DOS_HEADER.e_lfanew, dd NT_Signature - IMAGEBASE
...
resource_data:
Msg db " * resource stored in header and shuffled resource structure", 0ah, 0
RESOURCE_SIZE equ $ - resource_data
}}}
 * resource strings have their own awkward format.

=====exception=====
not covered here

=====security=====
not covered here

===relocations===
 * relocations are used when the PE is loaded at a different !ImageBase. Hardcoded Addresses such as `push <addr>` and `call [<addr>]` have to be adjusted.
 * relocations size is compulsory to tell the loader when to stop.
  * `dll.dll` contains simple relocations:
 {{{
    at IMAGE_DATA_DIRECTORY_16.FixupsVA,   dd Directory_Entry_Basereloc - IMAGEBASE
    at IMAGE_DATA_DIRECTORY_16.FixupsSize, dd DIRECTORY_ENTRY_BASERELOC_SIZE
...
reloc01:
    push detach
reloc22:
    call [__imp__printf]
...
Directory_Entry_Basereloc:
block_start0:
    .VirtualAddress dd reloc01 - IMAGEBASE
    .SizeOfBlock dd BASE_RELOC_SIZE_OF_BLOCK0
    dw (IMAGE_REL_BASED_HIGHLOW << 12) | (reloc01 + 1 - reloc01)
    dw (IMAGE_REL_BASED_HIGHLOW << 12) | (reloc22 + 2 - reloc01)
BASE_RELOC_SIZE_OF_BLOCK0 equ $ - block_start0
...
DIRECTORY_ENTRY_BASERELOC_SIZE  equ $ - Directory_Entry_Basereloc
}}}

 * IMAGE_REL_BASED_ABSOLUTE doesn't do anything, used for padding.
 * IMAGE_REL_BASED_HIGHLOW is the 'standard' relocation, for which `<real base> - ImageBase` will be added to the pointed address
 * IMAGE_REL_BASED_HIGH does the same but only the highest WORD of the delta is added. (in short, same operation one WORD earlier)
 * IMAGE_REL_BASED_LOW does the same but only the lowest WORD of the delta is added, which makes no change, as both bases are 10000h-aligned.
 * Other sort of relocations such as Mips and 64 bits are still supported by Windows 7.
 * forcing the binary to relocate to a known place (ex, with a null or kernel !ImageBase) makes it possible for the relocations to have predictable behavior. Thus, they can be used to decrypt or clear some values in memory. Also, relocations may be used to modify themselves.
  * `reloccrypt.exe` has a 0ffff0000h !ImageBase, and its relocations are, first, modifying themselves, using uncommon relocation types, then decrypting the code to be executed.
 {{{
EntryPoint:
reloc01:            ;68h push VDELTA + msg
crypt168 db 0
    dd VDELTA + msg
...
Directory_Entry_Basereloc:
; this block will fix the SizeOfBlock of the next block
block_start:
    .VirtualAddress dd VDELTA + relocated_reloc - IMAGEBASE
    .SizeOfBlock dd BASE_RELOC_SIZE_OF_BLOCK
    dw (IMAGE_REL_BASED_HIGHLOW << 12) ; + 10000h
    dw (IMAGE_REL_BASED_ABSOLUTE << 12)
    dw (IMAGE_REL_BASED_HIGHLOW << 12) ; + 10000h
    dw (IMAGE_REL_BASED_HIGHADJ << 12)
    dw (IMAGE_REL_BASED_HIGH    << 12) ; + 00001h
    dw (IMAGE_REL_BASED_LOW     << 12) ; + 0
    dw (IMAGE_REL_BASED_SECTION << 12)
    dw (IMAGE_REL_BASED_REL32 << 12)
...
;this block is actually the genuine relocations
block_start0:
    .VirtualAddress dd VDELTA + reloc01 - IMAGEBASE
relocated_reloc:
    .SizeOfBlock dd BASE_RELOC_SIZE_OF_BLOCK0 - 40002h
...
%macro cryptblock 2
block_start%1:
    .VirtualAddress dd VDELTA + %1 - IMAGEBASE
    .SizeOfBlock dd BASE_RELOC_SIZE_OF_BLOCK%1
    dw (IMAGE_REL_BASED_ABSOLUTE << 12)
    times %2 / 2 dw (IMAGE_REL_BASED_HIGH << 12)
BASE_RELOC_SIZE_OF_BLOCK%1 equ $ - block_start%1
%endmacro

;these blocks are the ones to implement the decryption
cryptblock crypt168, 068h
...
}}}
===debug===
 * under XP, the value of the Debug directory *SIZE* can't be random - even if the RVA is null !
  * thus, it's one of the rare data directory size that makes a difference.

===description===
 * Watcom compilers makes it point to a string. Useless whatsoever.

=====MIPS=====
not covered here

===TLS===
 * most values of TLS structures are not required:
  * `tls.exe` executes TLS code with the following structure
 {{{
    at IMAGE_DATA_DIRECTORY_16.TLSVA,       dd Image_Tls_Directory32 - IMAGEBASE
...
Image_Tls_Directory32:
    StartAddressOfRawData dd 0
    EndAddressOfRawData   dd 0
    AddressOfIndex        dd some_value
    AddressOfCallBacks    dd CallBacks
    SizeOfZeroFill        dd 0
    Characteristics       dd 0
...
some_value dd 012345h

CallBacks:
    dd tls
    dd 0
...
tls:
   <...>
}}}
 * The callbacks are VAs, not RVAs (!ImageBase *is* included).
 * each callback is executed until an error happens or a null dword is next in the list. then, no matter what happened (error or not) the !EntryPoint is executed:
  * a TLS doesn't need to return cleanly if it knows it's the last one
   * CoST uses this technique
  * an incorrect entry in the list doesn't create an entry
   * `tls_obfuscation.exe` has many fake TLS callback entries to disrupt disassembly
 * like the entrypoint value, a callback VA is blindly called. It can be:
  * outside the PE, in a known in advance address
  * pointing an Import Address Table entry, which means an API will be called with !ImageBase as parameter.
   * `tls_import.exe` executes `mz.exe` via a call to !WinExec through a TLS callback in its IAT.
 * under XP, TLS are only executed with staticly loaded DLL, not dynamicly loaded ones.
 * on XP, TLS are executed twice, on process start and process termination. Thus, code *is* executed even after a call to !ExitProcess.
 This is true even under Windows 7, however libraries such as user32.dll might be already unloaded, preventing code using it to work normally.
 * TLS callbacks are not executed if no DLL importing kernel32 is imported. Thus, no execution if kernel32 is the only import.
 * TLS callbacks' list is updated at each callback execution. If a TLS or the !EntryPoint code add or remove an entry, it will be taken into consideration
  * `tls_onthefly`'s first TLS adds a second one on the list that will be executed directly after the first one is over
 {{{
tls:
...
    mov dword [CallBacks + 4], tls2
    retn
...

tls2:
...
}}}

=====Load config=====
this is not explored yet.

===Bound import===
 * are a shortcut structure to hardcode some imports values in advance, to make import values faster
 * all the loader does is take a filename, compare the timestamp of the file and the one included in the bound imports table, then use the VA directly as import if they match.
  * `dllbound-ld.exe` loads and execute 'dllbound.dll' via bound imports.
 {{{
  at IMAGE_DATA_DIRECTORY_16.BoundImportsVA,   dd BoundImports - IMAGEBASE
  ...
  BoundImports:
  dd 31415925h ; timestamp of the bound DLL
  dw bounddll - BoundImports ; it's a WORD relative offset :(
  dw 0
  ...
  bounddll db 'dllbound.dll', 0 ; we have to duplicate locally this string... :(
  ...
  dll.dll_iat:
  __imp__export:
     dd 01001008h ;VA of the export of the loaded DLL
}}}

  * thus, replacing the RVA in the bound import table is an easy way to redirect imports.
   * `dllbound-redirld.exe` will load the wrong import of `dllbound.dll` because one RVA has been changed.
   {{{
dll.dll_iat:
__imp__export:
   dd 01001018h ; corrupted VA of the import
}}}

  * under XP only, it's even possible to put a different filename and timestamp. a completely different DLL will be used no matter what the standard import table says.
   * `dllbound-redirldXP.exe` will load the wrong dll `dllbound2.dll`, as the name and timestamp have been modified.
   {{{
BoundImports:
dd 27182818h ; timestamp of the hijacking DLL
dw bounddll - BoundImports
dw 0

;terminator
dd 0, 0

bounddll db 'dllbound2.dll', 0 ; hijacking DLL name
}}}

===Import table===
 * the RVA *and* the Size required to be set on a low alignment PE to make the import table writeable, under XP.
  * `nosectionXP.exe` needs an IAT to make its imports writeable

===delay imports===
 * it's just trampoline added by the compiler to load imports and DLL on request

=====COM Runtime=====
this is not explored yet.

======reserved======
 * used by packers and malware as markers

==section table==

=====Name=====
 * no importance whatsoever

===!Misc_VirtualSize===

===!VirtualAddress===

===!SizeOfRawData===

===!PointerToRawData===

=====!PointerToRelocations/!PointerToLinenumbers/!NumberOfRelocations/!NumberOfLinenumbers=====
 * no importance whatsoever

===Characteristics===
    at IMAGE_SECTION_HEADER.Characteristics,  dd IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE

----

=specific cases=

==folded header==

==PE + PDF==

----

=Greetings=
 * Peter Ferrie

 * Costin Ionescu
 * Ivanlef0u
 * Kris Kaspersky
 * Moritz Kroll

=Other resources=
 * the PE format
 * [http://www.reversinglabs.com/advisory/pecoff.php Undocumented PE/COFF]
