#summary x86 oddities

This pages enumerates various oddities of the x86/x64.

They are all implemented and tested in [StandardTest Standard Test].

=registers=
MMX and FPU registers are mapped on each others, but in opposite directions: 0, 1,2,3... mapped to 7,6,5...

Thus, a single FPU operation on ST0 will modify FST, ST0, but also MM7 (and CR0, under XP).
{{{
d9eb: fldpi

=> fst = 03800h
   st0 = 04000c90fdaa22168c235h
   mm7 =     0c90fdaa22168c235h
   cr0 = 080010031h (under XP)
}}}

==gs==
on 32bit Windows, GS is not saved in the context: When the OS switch from an application to another, the content of GS is lost. This can be used as an anti-emulator or an anti-stepping.

----

=aad=
_aad_  is officially defined to use 10/0Ah as operand, but can just use any other operand.

it makes it the first Add and Multiply opcode, as `al = ah * operand + al`
{{{

ax = 325h

d507: aad 7

=> ax = 3 * 7 + 25h = 3ah
}}}

=aam=
similar logic for _aam_: 
 * it's officially defined with 10/0ah, but it just works with any byte. 
 * it's a division, and quotient and remainder go to _ah_/_al_
{{{
al = 3ah

d403: aam 3

=> ah = 3ah / 3 = 13h
   al = 3ah % 3 = 1
}}}

=bswap=
`bswap <reg16>` is *officially* undefined. In *reality*, it just clears the register.
{{{
66 0fc8: bswap ax 

=> ax = 0
}}}

=cmpxchg8b=
`lock cmpxchg8b` doesn't crash CPUs anymore, but some tools might still show obsolete warnings about it.

<wiki:comment>* TBC writes the target address even though the content is unchanged.</wiki:comment>

=crc32=
the crc32 opcode implements the full algorithm with a single operation, however, it's not the commonly used CRC32 (used in Zip), but actually the CRC-32C (Castagnoli CRC-32), which uses a different polynomial. 

While it's technically the same algorithm as the 'common' CRC32, it uses a different seed, which makes it more efficient, but it just produces different results, so it's useless for Zip, and all the countless applications of the deflate algorithm.
{{{
eax = 0abcdef9h
ebx = 12345678h

f2 0f 38f1c3: crc32 eax, ebx

=> eax, 0c0c38ce0h
}}}

=mov=
 * mov to/from control and debug registers ignores the ModRM.
{{{
0f 2000: mov eax, cr0
}}}
 by the usual standards it should be an invalid `mov [eax], cr0`, but isn't.
 * `mov <reg32>, <selector>` is officially MOV, (not MOVZX) yet it modifies the full DWORD. the upper word is undefined on <Pentium, and null on later CPUs.
{{{
8cc8: mov eax, cs

=> eax = 1bh (xp)
}}}

=push=
segments and selectors are WORDS-sized registers, like AX, ..., however they're not pushed on the stack the same way.
{{{
1e: push ds

=> esp = esp + 4
   word ptr [esp] = ds
}}}

{{{
66 50: push ax

=> esp = esp + 2
   word ptr [esp] = ax
}}}

=movbe=
 * `movbe` is is a recent opcode equivalent to `mov + bswap`. 
{{{
[ebx] = 011223344h

0f 38f003: movbe eax, [ebx]

=> eax = 044332211h
}}}
 * It's found only on Atom CPUs. Thus, netbooks support it, but not powerful CPUs such as i7.

<wiki:comment>
=lzcnt=
 * TBC `lzcnt` is overlapped with popcnt
</wiki:comment>

=sal=
Shift Arithmetic Left is identical to SHL, and is usually encoded directly as SHL: this means that assemblers always generates the SHL opcode, so SAL is sometimes totally ignored by disassemblers/emulators/...

{{{
al = 1010b

c0f0 02: sal al, 2

=> al = 101000b
}}}


=salc=
 * `salc` is sometimes written `setalc`
 * it stands for `Set AL on Carry`
 * it's is undocumented by Intel - but not AMD, and it's unexpectedly supported by Intel's public tools.
 * it's a one byte equivalent to `SBB al, al`

{{{
f9: stc
d6: salc

=> al = -1
}}}

=str/sldt=
like SMSW, they work on DWORD or WORD on registers, but only on WORD in memory.

{{{
   0f 00c8: str eax

=> eax = 00000028h (XP)
}}}

{{{
66 0f 00c8: str ax

=> ax  =     0028h (XP)
}}}

{{{

   0f 0008: str [eax]

=> word ptr [eax] = 0028h (XP)
}}}

=lock=
lock works only on memory targets:
 * `f0 0100: lock:add [eax], eax` is valid
 * `f0 01c0: lock:add eax, eax` and `f0 0300: lock:add eax, [eax]` trigger exceptions

and on the following opcodes:
 * adc, add, and, or, sbb, sub, xor, dec, inc, neg, not
 * cmpxchg, cmpxchg8b
 * btr, bts, btc
  * `f0 0fa300: lock:bt [eax], eax` *does* trigger an exception
 * xadd, xchg (even if they are already atomic, so the lock is superfluous)

==XP bug==
Lock is wrongly parsed by Windows XP:
 # Upon an exception, XP tries to determine whether it should be an INVALID LOCK SEQUENCE or just an ILLEGAL INSTRUCTION
 # but it checks too briefly for a F0 byte: in the case of `FEF0`, which is just undefined, an INVALID LOCK SEQUENCE is still triggered by XP even if in this case, it has nothing to do with a lock prefix. For reference, FEC0 decodes as `inc al`.

Windows 7 just avoids the problem altogether by triggering an ILLEGAL INSTRUCTION on all invalid opcodes, including invalid use of LOCK: prefix. No parsing, no mistake !

=smsw=
 * gives CR0 value (word or dword)
 * unprivileged, unlike `mov eax, cr0` (old 286 instructions, mov cr0 is only present in 386)
 * upper bits are officially undefined. but still CR0 contents.
  ex:
{{{

0f 01e0: smsw eax

=> eax = 8001003b (XP)
}}}
 * since CR0 is influenced by other events (FPU) under XP, it makes it a tough anti-emulator.
 * `smsw` is defined on DWORD or WORD on registers, but always on WORD in memory.

=test=
`test <r32>, <imm32>` has an alternate encoding that is sometimes forgotten, as it's never generated by compilers or assemblers.
{{{
f7c8 44332211: test eax, 11223344h
}}}

=IceBP=
 * like `salc`, `IceBP` is undocumented by Intel, but not by AMD, and supported by Intel tools.
 * it stands for [http://en.wikipedia.org/wiki/In-circuit_emulator In-Circuit Emulator] Breakpoint. 
 * it's unprivileged
 * it triggers a SINGLE STEP exception, *after* execution.
 * it's sometimes written `Int1`, as it's the stepping interrupt, but executing Int1 doesn't trigger SINGLE STEP.

{{{
f1: IceBp

=> SINGLE STEP (80000004h) exception
}}}

=rdtscp=
_rdtscp_ is a recent opcode that just returns the usual _rdtsc_ result to eax/edx, and also changes ECX: it's  'loaded with the low-order 32-bits of
IA32_TSC_AUX MSR' ... which means most of the time, 0.

{{{
0f 01f9: rdtscp

=> edx:eax = <rdtsc>
   ecx = 0
}}}

=hint nop=
 * `hint nop` is officially documented by Intel as opcode `0f 1f`, but it's actually available on range `0f 19-1f` 
 * as one would expect from a nop, it never triggers an exception even when referencing an invalid address.

{{{
0f1980 00000080: nop [eax + 8000000h] 

=> nothing
}}}

=branch hints=
 * branch hints are officially define to give hints to the CPU whereas a branch is likely to be taken or not.
 * they are supposedly generated by compilers, but there is no official way to assemble or disassemble them.
 * they are re-using the 2e/3e bytes, which are mapped to CS: and DS: prefixes.

=16b flow=
 * call, jumps, return, loops can either jump to 32b or 16b via the 66: prefix.
 * there is no official way to disassemble a return to word : `small retn`, `retn word`, `retn.w`...

{{{
68 00104000: push 401000h
66 c3:       retn

=> EIP = 00001000h
   ESP = ESP - 2
}}}


----

=x64=

==32b zero extending==
in 64b, opcodes are zero-extending on 32b registers.

thus, while
{{{
   fec0: inc al
66 ffc0: inc ax
   ffc0: inc rax
}}}
all do what you would expect.

but on the other hand, {{{48 ffc0: inc eax}}} resets the upper 32 bits of `rax`.

==switching between 32b and 64b modes==
on a 64b CPU, the cpu can just change from/to 32b mode by jumping to a properly defined selector. In short, changing the number of bits just mean jumping to a different value of CS.

for example, in a 64b version of windows, selector 33h is for 64b. Jumping to it from a 32b process, then jumping back, will switch to 64b, then back to 32b. It's as simple as that.
{{{
    <32b>
call far 33h:_64b
    <32b>

_64b:
    <64b>
    ...
    retf
}}}
===32+64===
since there are some opcodes specific to 32b (arpl, ...), and others specific to 64b (movsxd, ...), the same hex data can lead to completely different disassembly, just because CS is different at the start.

----
====References====
 * Peter Ferrie
 * Moritz Kroll
 * Jon Larimer
 * ...you ?