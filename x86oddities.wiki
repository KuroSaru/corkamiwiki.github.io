#summary x86 oddities

This page enumerates various oddities of the x86/x64.

They are all implemented and tested in [StandardTest Standard Test].

=registers=
MMX and FPU registers are mapped on each others, but in opposite directions: 0, 1,2,3... mapped to 7,6,5...

Thus, a single FPU operation on ST0 will modify FST, ST0, but also MM7 (and CR0, under XP).
{{{
d9eb: fldpi

=> fst = 03800h
   st0 = 04000c90fdaa22168c235h
   mm7 =     0c90fdaa22168c235h
   cr0 = 080010031h (under XP)
}}}

==GS==
On 32bit Windows, GS is not saved in the execution context: When the OS switches from an application to another, the content of GS is lost. This can be used as an anti-emulator or an anti-stepping: after some time of execution, GS will eventually be reset:
 # set GS to X
 # wait until GS is null `<== thread switch eventually happens, and resets GS`
 # execution resume here

----

=aad=
`aad` is officially defined to use only 10/0Ah as a default operand, but can just use any other operand.

it makes it the first Add and Multiply opcode, as `al = ah * operand + al`.
{{{

ax = 325h

d507: aad 7

=> ax = 3 * 7 + 25h = 3ah
}}}

=aam=
Similar logic for `aam`: 
 * it's officially defined with 10/0ah, but it just works with any byte.
 * it's a division, and quotient and remainder go to `ah` and `al` respectively.

{{{
al = 3ah

d403: aam 3

=> ah = 3ah / 3 = 13h
   al = 3ah % 3 = 1
}}}

=bswap=
`bswap` is *officially* undefined on WORDS. In *reality*, it just clears the register, unexpectedly.
{{{
66 0fc8: bswap ax 

=> ax = 0
}}}

=cmpxchg8b=
`lock cmpxchg8b` doesn't crash CPUs anymore, but some tools might still show obsolete warnings about it.

=crc32=
The `crc32` opcode implements the full algorithm with a single operation, however, it's not the commonly used CRC32 (used in Zip), but actually the CRC-32C (Castagnoli CRC-32), which uses a different polynomial.

While it's technically the same algorithm as the 'common' CRC32, it uses a different seed, so it gives different results, thus it's useless for Zip, and all the countless applications of the deflate algorithm. 
{{{
eax = 0abcdef9h
ebx = 12345678h

f2 0f 38f1c3: crc32 eax, ebx

=> eax, 0c0c38ce0h
}}}

It's still usable independently as a checksum: it's actually more efficient than the standard CRC32 (when used for recovery purposes), but it's incompatible.

=mov=
 * mov to/from control and debug registers ignores the ModRM.
{{{
0f 2000: mov eax, cr0
}}}
 by the usual standards. it should have been decoded as `mov [eax], cr0`, which would be invalid, but it's an exception.
 * `mov <reg32>, <selector>` is officially MOV, (not MOVZX) yet it modifies the full DWORD from a WORD. (the upper word is supposedly undefined on CPUs older (or equal) to Pentium, but it's zero on a Pentium anyway). In any case, the upper word is null on modern CPUs.
{{{
8cc8: mov eax, cs

=> eax = 0000001bh (xp)
}}}

=push=
Even though selectors are WORDS-sized registers, like standard registers such as AX, they're not pushed on the stack the same way.
{{{
1e: push ds

=> esp = esp - 4
   word ptr [esp] = ds
}}}

{{{
66 50: push ax

=> esp = esp - 2
   word ptr [esp] = ax
}}}

no other word is changed.

=movbe=
 * `movbe` is is a recent opcode equivalent to `mov + bswap`. 
{{{
[ebx] = 011223344h

0f 38f003: movbe eax, [ebx]

=> eax = 044332211h
}}}
 * It's found only on Atom CPUs. Thus, netbooks support it, but not powerful CPUs such as i7.

<wiki:comment>
TODO:
* cmpxchg8b writes the target address even though the content is unchanged.
=lzcnt=
 * TBC `lzcnt` is overlapped with popcnt

ANDN
</wiki:comment>

=sal=
Shift Arithmetic Left (the opcode with modRM 110) is identical to SHL (opcode with modRM 100), and is usually encoded directly as SHL: this means that assemblers always generates the SHL opcode, so SAL is sometimes totally ignored by disassemblers/emulators/...

{{{
al = 1010b

c0f0 02: sal al, 2

=> al = 101000b
}}}

It's informally called SAL, because it's technically a different opcode (in hex), but functionally, it's the same as SHL.

|| modRM || 100 || 101 || 110 || 111 ||
|| opcode || SHL || SHR || 'SAL' || SAR ||

=salc=
 * `salc` is sometimes written `setalc`
 * it stands for `Set AL on Carry`
 * it's undocumented by Intel - but not by AMD, and it's unexpectedly supported by Intel's public tools.
 * it's a one byte equivalent of `1ac0: sb al, al`
  * al = cf ? -1 : 0

{{{
f9: stc
d6: salc

=> al = -1
}}}

=lock=
`lock:` works only on memory targets:
 * `f0 0100: lock:add [eax], eax` is valid.
 * `f0 01c0: lock:add eax, eax` and `f0 0300: lock:add eax, [eax]` trigger exceptions.

and on the following opcodes:
 * adc, add, and, or, sbb, sub, xor, dec, inc, neg, not
 * cmpxchg, cmpxchg8b
 * btr, bts, btc
  * `f0 0fa300: lock:bt [eax], eax` *does* trigger an exception.
 * xadd, xchg (even if they are already atomic, so `lock:` is superfluous)

==XP bug==
`lock:` is wrongly parsed by Windows XP:
 # Upon an exception, XP tries to determine whether it should be an INVALID LOCK SEQUENCE or just an ILLEGAL INSTRUCTION
 # but it checks too briefly for a F0 byte: in the case of `FEF0`, which is just undefined, an INVALID LOCK SEQUENCE is still triggered by XP even if, in this case, it has nothing to do with a `lock` prefix (For reference, `FEC0` decodes as `inc al`)

Windows 7 just avoids the problem altogether by triggering an ILLEGAL INSTRUCTION on all invalid opcodes, no matter what, including invalid use of LOCK: prefix. No parsing, no mistake !

{{{
fef0: ??

=> INVALID LOCK SEQUENCE (XP, bug)
   ILLEGAL INSTRUCTION (W7)
}}}

=smsw=
 * gives CR0 value (WORD or DWORD)
 * unprivileged, unlike `mov eax, cr0`: it's an old 286 instructions, while `mov cr0` is only present in 386 and later.
 * upper bits are officially undefined. but in reality, they're just CR0 contents.

{{{

0f 01e0: smsw eax

=> eax = 8001003b (XP)
}}}
 * since CR0 is influenced by other events (FPU) under XP, it makes it a tough anti-emulator.
 * `smsw` is defined on DWORD or WORD on registers, but always on WORD in memory(see below).

=str/sldt=
Like `smsw`, they work on DWORD or WORD on registers, but only on WORD in memory.

{{{
   0f 00c8: str eax

=> eax = 00000028h (XP)
}}}

{{{
66 0f 00c8: str ax

=> ax  =     0028h (XP)
}}}

{{{

   0f 0008: str [eax]

=> word ptr [eax] = 0028h (XP)
}}}

it's the same for `sldt`.

=test=
`test <r32>, <imm32>` has an alternate encoding that is sometimes forgotten, as it's never generated by compilers or assemblers.
{{{
f7c8 44332211: test eax, 11223344h
}}}

=IceBP=
 * like `salc`, `IceBP` is undocumented by Intel, but not by AMD, and supported by Intel tools.
 * it stands for [http://en.wikipedia.org/wiki/In-circuit_emulator In-Circuit Emulator] Breakpoint. 
 * it's unprivileged.
 * it triggers a SINGLE STEP exception, *after* execution.
 * it's sometimes written `Int1`, as it's the stepping interrupt, but executing `CD 01:Int 1` doesn't trigger SINGLE STEP.

{{{
f1: IceBp

=> SINGLE STEP (80000004h) exception
}}}

=rdtscp=
`rdtscp` is a recent opcode that just returns the usual `rdtsc` result to eax/edx, and also changes ECX: it's  _loaded with the low-order 32-bits of
IA32_TSC_AUX MSR_ ... which means most of the time, 0.

{{{
0f 01f9: rdtscp

=> edx:eax = <rdtsc>
   ecx = 0
}}}

=hint nop=
 * `hint nop` is officially documented by Intel as opcode `0f 1f`, but it's actually available on range `0f 19-1f`.
 * as one would expect from a `nop`, it never triggers an exception, even when referencing an invalid address.

{{{
0f1980 00000080: nop [eax + 8000000h] 

=> nothing
}}}
 * but, of course, if the operand is on an invalid page, it can still trigger an exception.

=branch hints=
 * branch hints are officially defined to give hints to the CPU whereas a branch is likely to be taken or not.
 * they are supposedly generated by compilers, but there is no official way to assemble or disassemble them.
 * they are re-using the 2e/3e bytes, which are mapped to `CS:` and `DS:` prefixes.

=16b flow=
 * call, jumps, return, loops can either jump to 32b or 16b via the `66:` prefix.
 * there is no official way to disassemble a return to word : `small retn`, `retn word`, `retn.w`...

{{{
68 00104000: push 401000h
66 c3:       retn

=> eip = 00001000h
   esp = esp - 2
}}}


----

=x64=

==32 bits zero extending==
In 64 bits, opcodes are zero-extending on 32 bits registers.

thus, while
{{{
   fec0: inc al
66 ffc0: inc ax
   ffc0: inc rax
}}}
all do what you would expect.

but on the other hand, 
{{{
48 ffc0: inc eax
}}}
resets the upper 32 bits of RAX.

==switching between 32b and 64b modes==
On a 64 bits CPU, the cpu can just change from/to 32b mode by jumping to a properly defined selector. In short, changing the number of bits just mean jumping to a different value of CS.

For example, in a 64b version of windows, selector 33h is for 64b. Jumping to it from a 32b process, then jumping back, will switch to 64b, then back to 32b. It's as simple as that.
{{{
    <32b>
call far 33h:_64b
    <32b>

_64b:
    <64b>
    ...
    retf
}}}

===32+64===
Since there are some opcodes specific to 32 bits mode (arpl, ...), and others specific to 64 bits mode (movsxd, ...), the same hex data can lead to completely different disassembly, just because CS is different at the start.

----

====References====
 * Peter Ferrie
 * Moritz Kroll
 * Jon Larimer