#summary x86 oddities

=registers=
MMX and FPU registers are mapped on each other, but in opposite directions. Thus, a single FPU operation (here, after initialization) will modify FST, ST0, but also MM7, and CR0 - under XP.
{{{
dbe3 finit
d9eb fldpi
 => fst = 0x3800
    st0 = 0x4000c90fdaa22168c235
    mm7 =     0xc90fdaa22168c235
    cr0 = 0x80010031 (XP)
}}}

----

=aad=
_aad_  is by default using 10/0xA as operand, but can just use any other operand.
it makes it the first Add and Multiply opcode, as `al = ah * operand + al`
{{{

ax = 0x325

d507 aad 7

==> ax = 0x3A
}}}

=aam=
similar logic for _aam_: quotient and remainder go to _ah_/_al_
{{{
al = 0x3a

D403 aam 3

=> ah = 0x3a / 3 = 0x13
   al = 0x3a % 3 = 1
}}}

=bswap=
`bswap <reg16>` is officially undefined. it just clears the registers.
{{{
66:0fc8 bswap ax 

=> ax = 0
}}}
=cmpxchg8b=
 * TBC writes the target address even though the content is unchanged
 * `lock cmpxchg8b` (TBC) doesn't crash CPUs anymore, but some tools might still show obsolete warnings about it.

=crc32=
the crc32 opcode implements the full algorithm with a single operation, however, it's not the commonly used CRC32 (used in Zip), but actually the CRC-32C (Castagnoli CRC-32), which uses a different polynomial. 

While it's technically the same algorithm as the 'common' CRC32, it uses a different seed, which makes it more efficient, but it just produces different results, so it's useless for Zip, and all the countless applications of the deflate algorithm.
{{{
eax = 0abcdef9h
ebx = 12345678h

f2 0f 38 f1c3 crc32 eax, ebx
=> eax, 0c0c38ce0h
}}}
=mov=
 * mov to/from control and debug registers ignores the ModRM.
{{{
0f2000 mov eax, cr0
}}}
 by the usual standards it should be an invalid `mov [eax], cr0`, but isn't.
 * `mov <reg32>, <selector>` is officially MOV, (not MOVZX) yet it modifies the full DWORD. the upper word is undefined on <Pentium, and null on later CPUs.
{{{
8CC8 mov eax, cs => eax = 0x1b (xp)
}}}

=push=
 * `push <selector>` TODO
 * `push <reg16>` TODO

=movbe=
`movbe` is 'equivalent' to mov + bswap is an Atom opcode. It's supported by netbooks, but not by powerful desktop/laptop with I7 cpus
{{{
[ebx] = 0x11223344

0f38f003 movbe eax, [ebx]

=> eax = 0x44332211h
}}}
=lzcnt=
 * TBC `lzcnt` is overlapped with popcnt

=sal=

=salc=

=sldt=
 * TBC word only on register, word or dword on memory

=lock=
lock works only on memory target:
 * `F0:0100 lock:add [eax], eax` is valid
 * `F0:01C0 lock:add eax, eax` and `F0:0300 lock:add eax, [eax]` trigger exceptions

and on the following opcodes:
 * adc, add, and, or, sbb, sub, xor, dec, inc, neg, not
 * cmpxchg, cmpxchg8b
 * btr, bts, btc
  * `f0:0fa300 lock:bt [eax], eax` *does* trigger an exception
 * xadd, xchg (even if they are already atomic, so the lock is superfluous

=smsw=
 * gives CR0 value (word or dword)
 * unprivileged, unlike `mov eax, cr0` (old 286 instructions, mov cr0 is only present in 386)
 * upper bits are officially undefined. but still CR0 contents.
  ex: `0f01e0 smsw eax` => `eax = 8001003B` (XP)

=test=

=rdtscp=
_rdtscp_ is a recent opcode that just returns the usual _rdtsc_ result to eax/edx, and also changes ECX: it's  'loaded with the low-order 32-bits of
IA32_TSC_AUX MSR' ... which means most of the time, 0.

{{{
0f01f9 rdtscp
 => edx:eax = <rdtsc>
    ecx = 0
}}}

----

=x64=

==32b zero extending==
in 64b, opcodes are zero-extending on 32b registers.

thus, while
{{{
inc al
inc ax
inc rax
}}}
all do what you would expect

{{{inc eax}}} resets the upper 32bits of `rax`

==switching between 32b and 64b modes==
on a 64b CPU, the cpu can just change from/to 32b mode by jumping to a properly defined selector. In short, changing the number of bits just mean jumping to a different value of CS.

for example, in a 64b version of windows, selector 33h is for 64b. Jumping to it from a 32b process, then jumping back, will switch to 64b, then back to 32b. It's as simple as that.
{{{
    <32b>
call far 33h:here
    <32b>

here:
    <64b>
    ...
    retf
}}}

since there are some opcodes specific to 32b (arpl, ...), and others specific to 64b (movsxd, ...), the same hex data can lead to completely different disassembly, just because CS is different at the start.