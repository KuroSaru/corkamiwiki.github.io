#summary a general introduction to binary packers
#labels Featured,Packer,Docs

Note that nothing in this page will match every packer out there. I just want to present various concepts that applies for most cases, mostly to help in documenting unpackmes.

= Introduction =

A packer is a generic word for a lot of different kind of tools, including: _compressor, encryptor, protector, obfuscater, patcher_...

Their common point is that they all create a new & different binary from a source binary, and the result should execute like the source binary.

they might compress the original data (_compressor_), encrypt it (_encryptor_), add some counter-measure (_protectors_, with anti-(debuggers/user/tools/VM...), obfuscate code with polymorphism or junk) (_scrambler_).

= Typical skeleton =
most packers follow this 5-parts schema.

 # the start: commercial packers want to be identified, so even the most advanced ones may start in some recognizable way. Some even include the packer's name in text form.
 # the trapped entrance: the part with the highest obfuscation, junk, polymorphism, counter-measures... usually decrypts next part
 # the data restoring part: this part restore the original data: decompression, decryption... usually with low or no protection at all.
 # the cleaning: remove as much data as possible to prevent easy unpacking. Like a hitman would clean his tracks.
 # the system part: this part has to reproduce some system mechanisms (imports loading, relocation...) to make the original binary run correctly.

= In details =

== Compression ==

the most common ones are [http://www.ibsensoftware.com/products_aPLib.html Aplib] (60%), [http://www.7-zip.org/sdk.html Lzma] (20%), and the rest...

== Encryption ==

a byte or dword XOR is undoubtedly the most commonly used.

they are often used with ADD/ROL too.

As for 'real' algorithms, comes RC4, Tea, Blowfish, RSA...

= Example = 
{{{
    jmp <here>                    ; start
 db 'My Packer 1.0',0

here:                             ; entrance
    <junk>                       
    check with IsDebuggerPresent
    <junk>
    check with 2 GetTickCount
    <junk>
    xor32 <part3>

part3:                            ; data restore
    call Aplib, <section content>
    loop part3

part4:                            ; cleaning
    call Overwrite, <original section table>
    call Overwrite, <packer start>

part 5:                           ;system
Dll:
    call LoadLibraryA, <DllName>
API:
    call GetProcAddress, <ApiName>
    loop API
    loop DLL

    jmp <OEP>
}}}

remember this is just an example and their is an exception for everything here.

= Tactics =

== Manual Dump ==
During the execution of most packer stubs, the original file is at some point fully restored in memory, and not executed yet. If we stop execution at this point, save it to disk, and revert the system part, we can get an unpacked image of the original file. So we try to _find the Original Entry Point_, get a _manual dump_. 

in short, it just consists in finding a shortcut: a bit like serial-fishing, you don't have to understand anything as long as you found the _clean restore point_.

Let's take a small example:
{{{
start:
    call <big complex algorithm with highly obfuscated code>
    jmp <OEP> // at this point the code is decrypted
}}}
to get a manual dump, just set a breakpoint at the `jmp`, and there you go.

However it's easy to prevent such a point to appear. And this tactic is not very interesting.

== Full Unpacking ==

This is the interesting part. Analyze and understand the whole packer stub, sort out what is junk and what is important, find out the _minimum_ information that you need to restore the original image in a _generic_ way.

And there is no trick here. it's pure fun !

no fast-forward trick, most tools won't even help you.

at least, here are some hints:
 # the first problem is the junk : identify it clearly, by writing some tools (as a start) or just getting used to it (better)
 # next problem is understanding how the polymorphism of the real instruction works.
 # at this point you should get an idea of what the packer does in its monomorphism-ed form. If you meet a big algorithm, it's probably something already documented out there, so train yourself to identify Aplib/Lzma first. If you don't know the algorithm you're facing, do some quick search on the web. If not successful, then just port it by hand. IDA & HexRay might help !

Excepting _rip-offs_, each packer is somehow different. Some junk engines are publicly available, many anti-debugs are common, but it's never really the same, so you can make a kind of fingerprint of packers thru the junk they use, their polymorphisms, their real code, their countermeasures, and what they actually do to the original data.
